---
title: "Into the tidyverse with introverse"
author: "dplyr::filter()"
output: 
  learnr::tutorial:
    theme: united
runtime: shiny_prerendered
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(learnr)
library(tidyverse)
tutorial_options(exercise.lines = 6)

set.seed(1)
iris %>%
  group_by(Species) %>%
  sample_n(3) %>%
  ungroup() -> iris9
```


# Understanding the `{dplyr}` function `filter()`


### The data

The examples will use the dataset `iris9`, which contains nine rows from the `iris` dataset:

```{r explore_iris}
iris9
```

### Using `filter()`


We use `{dplyr}` package function `filter()` to _subset rows_ from data frames. 

The function `filter()` takes at least two arguments:


+ First, the _name of the data frame_ whose rows you want to subset. 
+ Second, _a logical statement_ about the data. A logical statement is any piece of code that returns `TRUE` or `FALSE`.

The function `filter()` will only keep the data frame rows that the logical statement says are `TRUE`. In other words, it removes rows where the statement is `FALSE`.

```{r, eval=F}
# Syntax without pipe:
filter(name of a data frame, something that is TRUE or FALSE)

# Syntax with pipe:
name of a data frame %>%
  filter(something that is TRUE or FALSE)
```


### Interactive examples

When using `filter()`, we directly refer to column names (like `Species` from the `iris9` dataset) in our code to specify our `TRUE`/`FALSE` statement. Always make sure to spell column names with the same capitalization as they appear in the dataset.

When you run the code above, you will see that only three rows remain. Those rows are the only rows in the data which are "setosa" species irises.

```{r filter1, exercise=TRUE}
# From the iris9 dataset, keep only rows where it is TRUE that `Species equals 'setosa'`
filter(iris9, Species == "setosa")
```

```{r filter1-1, exercise=TRUE}
# Same code written in the preferred style. Using multiple lines makes our code easier to see.
iris9 %>%
  filter(Species == "setosa")
```



We can also use other _logical operators_ like this:
```{r filter3, exercise=TRUE}
# From the iris9 dataset, keep only rows where it is TRUE that sepal lengths are less than 5
iris9 %>%
  filter(Sepal.Length < 5)
```


If we want to specify multiple conditions, we just add more arguments to `filter()`, with commas in between:

```{r filter4, exercise=TRUE}
# From the iris9 dataset, keep only rows where it is TRUE that...
## sepal lengths are less than 5, AND
## petal lengths are greater than or equal to 1
iris9 %>%
  filter(Sepal.Length < 5, Petal.Length >=1)
```

The same task could be done with an ampersand `&`: 

```{r filter5, exercise=TRUE}
# From the iris9 dataset, keep only rows where it is TRUE that...
## sepal lengths are less than 5, AND
## petal lengths are greater than or equal to 1
iris9 %>%
  filter(Sepal.Length < 5 & Petal.Length >=1)
```

Or, if we want rows where _at least one_ option is `TRUE`, we use the symbol `|`:

```{r filter6, exercise=TRUE}
# From the iris9 dataset, keep only rows where it is TRUE that...
## sepal lengths are less than 5, OR
## petal lengths are greater than or equal to 1
iris9 %>%
  filter(Sepal.Length < 5 | Petal.Length >=1)
```